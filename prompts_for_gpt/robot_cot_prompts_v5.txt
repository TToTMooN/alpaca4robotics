You will be given a set of tasks in a robotic environment.
You are asked to simulate the task instructions and corresponding responses happening during task solving.
Some of them are long-horizon tasks request multiple reasoning steps, so we are generating multi-turn instructions in a chain of thought way. 
These task instructions will be given to a GPT model and we will evaluate the GPT model performance on the generated responses.

[General Environment Description] 
The environment is called "Block World". 
There is a 7DOF Franka Panda robot with a parallel gripper, it has a force sensor on the end effector. The robot is mounted on a table.
There are multiple blocks on tha table, here we use 2 blocks as example. The blocks are called {block A} and {block B}. If there are more than two blocks, they are called {block C}, {block D}, etc.
The blocks are initialized at a random position on the table.
The observation space (when there are two blocks) is a 26 dimension vector, consisting of:
block A position(3), block A orientation(4), block B position(3), block B orientation(4), end effector position(3), end effector orientation(4), end effector force(3), left finger position(1), right finger position(1) 
If there are more than two blocks, the observation space is a 26+7*(n-2) dimension vector, where n is the number of blocks.

[Extra Environment Assumption Tags]
<weight> The blocks have randomized weight.
<move> The blocks are randomly determined to be movable or not, at least one block is movable.
<three> There are three blocks in the environment. They are identical and movable if there is no <weight> or <move> tag.
<four> There are four blocks in the environment. 
Tags at the beginning of {TASK} represent the environment assumptions for the task.

[Instruction data Format]
The robot will be given a task: {TASK}. 
The instructions and responses happen when the robot is trying to solve this specific {TASK}, and ask a chatbot guider.
Each instruction data pair consists of three parts: {instruction}, {input}, {output}
The {instruction} consists of the question asked by the robot to help make decisions.
The {input} consists of the current observation and historical info. 
The {output} consists of two parts <verbal> and <action>.
    - The <verbal> part describe the reasoning process and explanation for the current planned action if there is any.
    - The <action> part include a downstream action provided in the function lists executable by the robot. 

The {instruction} of each task consists of the following standard questions in order to provide chain of thought instructions pairs.
1. Is the current information enough to solve the task? If not, what information is missing?
2. What are the actions the robot should take to gather information?
3. What are the actions the robot should take to solve the task?
For the 1st question, the <action> output part should be <nooutput>, only <verbal> output is important. The robot should ask this every time it collects new information. 
For the other questions, both <verbal> and <action> output parts are important. The 2nd question usually happens when the answer of previous round question 1 is no. The 3rd question usually happens when the answer of previous round question 1 is yes.
When generating instruction data, please imagine the observation and previous collected information for the robot, and generate the corresponding {input} and {output}.
There can be different responses to the same question depending on different {input}, imagine different scenarios and generate different responses. 

[Tasks to solve]
Below is the list of {TASK}s used in the generated instructions:
{TASK_LIST_PLACEHOLDER}

[Function Lists in skill library]
{FUNCTION_LIST_PLACEHOLDER}

[Example trajectories]
Below is some example trajectories(sequence of obs) when executing some skills. Use them as reference for observations when generating instructions.
{TRAJECTORY_PLACEHOLDER}

[Format of generated instructions]
1. The i-th response need to satisfy the following format, i starts from 1. 
// start of instruction pair i, not including this line.
###
i.
<Task> {task}
<Instruction> {instruction}
<Input> {input}
<Output>
[verbal] {verbal output}
[action] {list of function output}
// end of instruction pair i, not including this line.
2. The index of instructions for different tasks are continous. For example, if the last instruction for task 1 is 5, the first instruction data for task 2 should be 6.
3. The format of {instruction}: It's usually one of the questions listed above.
4. The format of {input} will be a vector of robot observation, followed by a list of historical information. Use actual numbers in the vectors. The format is: 
Current:\n[observation]\nPast:\n[hist text 1] [hist action list 1] [hist obs list 1]\n[hist text 2] [hist action list 2] [hist obs list 2]\n ...
[hist text] [hist action list] are the previous rounds explanation and action sequence, [hist obs list] is the observation after the action executions in previous rounds. The number of hist obs should correspond to the number of actions in hist action list. 
5. The format of {verbal output} will be a sentence explain the current reasoning process and the current planned action. It is used for in-context learning for multi-turn instructions.
6. The format of {action output} will be list of {function name} {function parameter} wrapped by []. Each element should be in a python executable form, don't use placeholders as parameters, output the numbers if the parameters are vectors.
7. Each instruction pair should be separated by a line of "###" at the beginning.
8. For each task in the task list, generate the multiple rounds of instructions from initial until the task is solved. At some steps, if there are multiple possible feecback observations, generate multiple data pairs with corresponding observations.
Generate instructions for task 1 first, then task 2, ..., task N. 
Each task should have at most 10 instruction pairs. Don't stop generating instructions until all the tasks listed are covered.

Examples of instruction pairs for a single turn are given below. Note that this could be instructions under different {TASK}s in different rounds. You need to modify the instruction pairs according to the {TASK}.
